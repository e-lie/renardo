import os

from pathlib import Path
from sys import platform

SC_USER_CONFIG_DIR = None

# default config path
# on windows AppData/Roaming/renardo
# on Linux ~/.config/renardo
# on MacOS /Users/<username>/Library/Application Support/renardo
if platform == "linux" or platform == "linux2" :
    home_path = Path.home()
    SC_USER_CONFIG_DIR = home_path / '.local' / 'share' / 'SuperCollider'
elif platform == "darwin":
    home_path = Path.home()
    SC_USER_CONFIG_DIR = home_path / 'Library' / 'Application Support' / 'SuperCollider'
elif platform == "win32":
    appdata_local_path = Path(os.getenv('LOCALAPPDATA'))
    SC_USER_CONFIG_DIR = appdata_local_path / 'SuperCollider'

SC_USER_EXTENSIONS_DIR = SC_USER_CONFIG_DIR / 'Extensions'

SCLANG_PROCESS = None

def is_renardo_sc_classes_initialized():
    """Check if SuperCollider classes are initialized and up to date"""
    files_exist = (
        (SC_USER_EXTENSIONS_DIR / 'Renardo.sc').exists()
        and (SC_USER_EXTENSIONS_DIR / 'StageLimiter.sc').exists()
        and (SC_USER_CONFIG_DIR / 'start_renardo.scd').exists()
    )
    
    # If files don't exist, they're not initialized
    if not files_exist:
        return False
    
    # If files exist but are outdated, they need to be reinitialized
    return not should_update_renardo_sc_classes()

def _generate_renardo_sc_class_content():
    """Generate the current expected content for Renardo.sc file"""
    from renardo.settings_manager import settings
    osc_port = settings.get("sc_backend.PORT")
    num_output_channels = settings.get("sc_backend.NUM_OUTPUT_BUS_CHANNELS")
    num_input_channels = settings.get("sc_backend.NUM_INPUT_BUS_CHANNELS")
    
    return f'''/*
 * WARNING: This file is auto-generated by Renardo.
 * DO NOT MODIFY MANUALLY - any changes will be overwritten automatically!
 * To customize SuperCollider settings, modify your Renardo settings instead.
 */

        Renardo {{
            classvar server;
            classvar midiout;

            *configure {{
                arg remote = false;
                // Create a custom server with the specified port using NetAddr
                server = Server(\\renardo, NetAddr("127.0.0.1", {osc_port}));
                server.options.memSize = 8192 * 16;
                server.options.maxNodes = 1024 * 32;
                server.options.numOutputBusChannels = {num_output_channels};
                server.options.numInputBusChannels = {num_input_channels};
                if (remote, {{
                    server.options.bindAddress = "0.0.0.0"; // allow connections from any address
                }});
            }}

            *oscAddSynthDefFromFile {{
                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var fn;
                        // Get local filename
                        fn = msg[1].asString;
                        // Print a message to the user
                        ("Loading SynthDef from" + fn).postln;
                        // Add SynthDef to file
                        fn = File(fn, "r");
                        fn.readAllString.interpret;
                        fn.close;
                    }},
                    path: 'foxdot'
                );

                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var fn;
                        // Get local filename
                        fn = msg[1].asString;
                        // Print a message to the user
                        ("Loading SynthDef from" + fn).postln;
                        // Add SynthDef to file
                        fn = File(fn, "r");
                        fn.readAllString.interpret;
                        fn.close;
                    }},
                    path: 'add-synthdef-file'
                );
            }}

            *oscAddSynthDefFromCode {{
                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var fn;
                        // Get local filename
                        fn = msg[1].asString;
                        // Print a message to the user
                        ("Loading SynthDef :" + fn).postln;
                        // Add SynthDef to file
                        fn = File(fn, "r");
                        fn.readAllString.interpret;
                        fn.close;
                    }},
                    path: 'add-synthdef-code'
                );
            }}

            *start {{
                arg remote = false;
                this.configure(remote);

                server.boot();

                this.oscAddSynthDefFromFile;
                this.oscAddSynthDefFromCode;

                StageLimiterBis.activate(2);

                ("Listening for messages from Renardo on port " ++ {osc_port}).postln;
            }}

            *startRemote {{
                this.start(true);
            }}

            *midi {{
                arg port=0;
                MIDIClient.init;
                midiout = MIDIOut(port);
                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var note, vel, sus, channel, nudge;
                        // listen for specific MIDI trigger messages from FoxDot
                        note    = msg[2];
                        vel     = msg[3];
                        sus     = msg[4];
                        channel = msg[5];
                        nudge   = msg[6];
                        SystemClock.schedAbs(time + nudge, {{midiout.noteOn(channel, note, vel)}});
                        SystemClock.schedAbs(time + nudge + sus, {{midiout.noteOff(channel, note, vel)}});
                    }},
                    path: 'foxdot_midi'
                );
                ("Sending Renardo MIDI messages to" + MIDIClient.destinations[port].name).postln;
            }}
        }}
'''

def should_update_renardo_sc_classes():
    """Check if the SuperCollider class files need to be updated"""
    renardo_file = SC_USER_EXTENSIONS_DIR / 'Renardo.sc'
    
    # If file doesn't exist, we need to create it
    if not renardo_file.exists():
        return True
    
    # Read current file content
    try:
        with open(renardo_file, 'r') as f:
            current_content = f.read()
    except (IOError, OSError):
        return True  # If we can't read it, better to regenerate
    
    # Generate expected content
    expected_content = _generate_renardo_sc_class_content()
    
    # Compare content (normalize whitespace)
    current_normalized = ' '.join(current_content.split())
    expected_normalized = ' '.join(expected_content.split())
    
    return current_normalized != expected_normalized

def write_sc_renardo_files_in_user_config():
    from renardo.settings_manager import settings
    osc_port = settings.get("sc_backend.PORT")
    
    # Ensure directories exist
    SC_USER_EXTENSIONS_DIR.mkdir(parents=True, exist_ok=True)
    SC_USER_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    
    # Use the helper function to generate consistent content
    renardo_sc_class = _generate_renardo_sc_class_content()

    stagelimiter_sc_class = '''
        // Batuhan Bozkurt 2009
        StageLimiterBis
        {
            classvar lmSynth, lmFunc, activeSynth;

            *activate
            { |numChannels = 2|
                fork
                {
                    lmFunc =
                    {
                        {
                            activeSynth =
                                Synth(\\stageLimiter,
                                    target: RootNode(Server.default),
                                    addAction: \\addToTail
                                );
                        }.defer(0.01)
                    };
                    lmSynth = SynthDef(\\stageLimiter,
                    {
                        var input = In.ar(0, numChannels);
                        input = Select.ar(CheckBadValues.ar(input, 0, 0), [input, DC.ar(0), DC.ar(0), input]);
                        ReplaceOut.ar(0, Limiter.ar(input)) ;
                    }).add;
                    Server.default.sync;
                    lmFunc.value;
                    CmdPeriod.add(lmFunc);
                    "StageLimiter active".postln;
                }
            }

            *deactivate
            {
                activeSynth.free;
                CmdPeriod.remove(lmFunc);
                "StageLimiter inactive...".postln;
            }
        }
    '''

    renardo_start_code = f'''
        Renardo.start({osc_port});
        Renardo.midi;
    '''

    with open(SC_USER_EXTENSIONS_DIR / 'StageLimiter.sc', mode="w") as file:
        file.write(stagelimiter_sc_class)

    with open(SC_USER_EXTENSIONS_DIR / 'Renardo.sc', mode="w") as file:
        file.write(renardo_sc_class)

    with open(SC_USER_CONFIG_DIR / 'start_renardo.scd', mode="w") as file:
        file.write(renardo_start_code)
