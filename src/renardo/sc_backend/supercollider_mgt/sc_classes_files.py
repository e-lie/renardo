import os

from pathlib import Path
from sys import platform

SC_USER_CONFIG_DIR = None

# default config path
# on windows AppData/Roaming/renardo
# on Linux ~/.config/renardo
# on MacOS /Users/<username>/Library/Application Support/renardo
if platform == "linux" or platform == "linux2" :
    home_path = Path.home()
    SC_USER_CONFIG_DIR = home_path / '.local' / 'share' / 'SuperCollider'
elif platform == "darwin":
    home_path = Path.home()
    SC_USER_CONFIG_DIR = home_path / 'Library' / 'Application Support' / 'SuperCollider'
elif platform == "win32":
    appdata_local_path = Path(os.getenv('LOCALAPPDATA'))
    SC_USER_CONFIG_DIR = appdata_local_path / 'SuperCollider'

SC_USER_EXTENSIONS_DIR = SC_USER_CONFIG_DIR / 'Extensions'

SCLANG_PROCESS = None

def is_renardo_sc_classes_initialized():
    """Check if SuperCollider classes are initialized and up to date"""
    files_exist = (
        (SC_USER_EXTENSIONS_DIR / 'Renardo.sc').exists()
        and (SC_USER_EXTENSIONS_DIR / 'StageLimiter.sc').exists()
        and (SC_USER_CONFIG_DIR / 'start_renardo.scd').exists()
    )
    
    # If files don't exist, they're not initialized
    if not files_exist:
        return False
    
    # If files exist but are outdated, they need to be reinitialized
    return not should_update_renardo_sc_classes()

def _generate_renardo_sc_class_content():
    """Generate the current expected content for Renardo.sc file"""
    from renardo.settings_manager import settings
    osc_port = settings.get("sc_backend.PORT")
    num_output_channels = settings.get("sc_backend.NUM_OUTPUT_BUS_CHANNELS")
    num_input_channels = settings.get("sc_backend.NUM_INPUT_BUS_CHANNELS")
    
    return f'''/*
 * WARNING: This file is auto-generated by Renardo.
 * DO NOT MODIFY MANUALLY - any changes will be overwritten automatically!
 * To customize SuperCollider settings, modify your Renardo settings instead.
 */

        Renardo {{
            classvar server;
            classvar midiout;

            *configure {{
                arg remote = false;
                // Create a custom server with the specified port using NetAddr
                server = Server(\\renardo, NetAddr("127.0.0.1", {osc_port}));
                server.options.memSize = 8192 * 16;
                server.options.maxNodes = 1024 * 32;
                server.options.numOutputBusChannels = {num_output_channels};
                server.options.numInputBusChannels = {num_input_channels};
                if (remote, {{
                    server.options.bindAddress = "0.0.0.0"; // allow connections from any address
                }});
            }}

            *oscAddSynthDefFromFile {{
                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var fn;
                        // Get local filename
                        fn = msg[1].asString;
                        // Print a message to the user
                        ("Loading SynthDef from" + fn).postln;
                        // Add SynthDef to file
                        fn = File(fn, "r");
                        fn.readAllString.interpret;
                        fn.close;
                    }},
                    path: 'foxdot'
                );

                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var fn;
                        // Get local filename
                        fn = msg[1].asString;
                        // Print a message to the user
                        ("Loading SynthDef from" + fn).postln;
                        // Add SynthDef to file
                        fn = File(fn, "r");
                        fn.readAllString.interpret;
                        fn.close;
                    }},
                    path: 'add-synthdef-file'
                );
            }}

            *oscAddSynthDefFromCode {{
                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var fn;
                        // Get local filename
                        fn = msg[1].asString;
                        // Print a message to the user
                        ("Loading SynthDef :" + fn).postln;
                        // Add SynthDef to file
                        fn = File(fn, "r");
                        fn.readAllString.interpret;
                        fn.close;
                    }},
                    path: 'add-synthdef-code'
                );
            }}

            *start {{
                arg remote = false;
                this.configure(remote);

                server.boot();

                this.oscAddSynthDefFromFile;
                this.oscAddSynthDefFromCode;

                StageLimiterBis.activate(2);

                ("Listening for messages from Renardo on port " ++ {osc_port}).postln;
            }}

            *startRemote {{
                this.start(true);
            }}

            *midi {{
                arg port=0;
                MIDIClient.init;
                midiout = MIDIOut(port);
                OSCFunc(
                    func: {{
                        arg msg, time, addr, port;
                        var note, vel, sus, channel, nudge;
                        // listen for specific MIDI trigger messages from FoxDot
                        note    = msg[2];
                        vel     = msg[3];
                        sus     = msg[4];
                        channel = msg[5];
                        nudge   = msg[6];
                        SystemClock.schedAbs(time + nudge, {{midiout.noteOn(channel, note, vel)}});
                        SystemClock.schedAbs(time + nudge + sus, {{midiout.noteOff(channel, note, vel)}});
                    }},
                    path: 'foxdot_midi'
                );
                ("Sending Renardo MIDI messages to" + MIDIClient.destinations[port].name).postln;
            }}

            *listAudioDevices {{
                "=== AUDIO DEVICES ===".postln;
                "".postln;
                
                "OUTPUT DEVICES:".postln;
                ("Number of Devices: " ++ ServerOptions.outDevices.size).postln;
                ServerOptions.outDevices.do({{ |device, index|
                    ("   " ++ index ++ " :  " ++ device).postln;
                }});
                
                "".postln;
                "INPUT DEVICES:".postln;
                ("Number of Devices: " ++ ServerOptions.inDevices.size).postln;
                ServerOptions.inDevices.do({{ |device, index|
                    ("   " ++ index ++ " :  " ++ device).postln;
                }});
            }}

            *listAudioDevicesJson {{
                var outDevices, inDevices;
                outDevices = Dictionary.new;
                inDevices = Dictionary.new;
                
                ServerOptions.outDevices.do({{ |device, index|
                    outDevices.put(index, device);
                }});
                
                ServerOptions.inDevices.do({{ |device, index|
                    inDevices.put(index, device);
                }});
                
                "RENARDO_AUDIO_DEVICES_START".postln;
                ("OUT:" ++ outDevices.asCompileString).postln;
                ("IN:" ++ inDevices.asCompileString).postln;
                "RENARDO_AUDIO_DEVICES_END".postln;
            }}
        }}
'''

def should_update_renardo_sc_classes():
    """Check if the SuperCollider class files need to be updated"""
    renardo_file = SC_USER_EXTENSIONS_DIR / 'Renardo.sc'
    stagelimiter_file = SC_USER_EXTENSIONS_DIR / 'StageLimiter.sc'
    start_file = SC_USER_CONFIG_DIR / 'start_renardo.scd'
    
    # If any file doesn't exist, we need to create them
    if not (renardo_file.exists() and stagelimiter_file.exists() and start_file.exists()):
        return True
    
    # Check Renardo.sc content
    try:
        with open(renardo_file, 'r') as f:
            current_renardo_content = f.read()
    except (IOError, OSError):
        return True  # If we can't read it, better to regenerate
    
    # Generate expected content for Renardo.sc
    expected_renardo_content = _generate_renardo_sc_class_content()
    
    # Compare Renardo.sc content (normalize whitespace)
    current_renardo_normalized = ' '.join(current_renardo_content.split())
    expected_renardo_normalized = ' '.join(expected_renardo_content.split())
    
    if current_renardo_normalized != expected_renardo_normalized:
        return True
    
    # Check other files exist and have some content (basic check)
    try:
        with open(stagelimiter_file, 'r') as f:
            stagelimiter_content = f.read().strip()
        with open(start_file, 'r') as f:
            start_content = f.read().strip()
        
        # Basic content check - files should not be empty and contain expected keywords
        if (not stagelimiter_content or 'StageLimiterBis' not in stagelimiter_content or
            not start_content or 'Renardo.start' not in start_content):
            return True
            
    except (IOError, OSError):
        return True
    
    return False

def write_sc_renardo_files_in_user_config():
    from renardo.settings_manager import settings
    osc_port = settings.get("sc_backend.PORT")
    
    # Ensure directories exist
    SC_USER_EXTENSIONS_DIR.mkdir(parents=True, exist_ok=True)
    SC_USER_CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    
    # Use the helper function to generate consistent content
    renardo_sc_class = _generate_renardo_sc_class_content()

    stagelimiter_sc_class = '''
        // Batuhan Bozkurt 2009
        StageLimiterBis
        {
            classvar lmSynth, lmFunc, activeSynth;

            *activate
            { |numChannels = 2|
                fork
                {
                    lmFunc =
                    {
                        {
                            activeSynth =
                                Synth(\\stageLimiter,
                                    target: RootNode(Server.default),
                                    addAction: \\addToTail
                                );
                        }.defer(0.01)
                    };
                    lmSynth = SynthDef(\\stageLimiter,
                    {
                        var input = In.ar(0, numChannels);
                        input = Select.ar(CheckBadValues.ar(input, 0, 0), [input, DC.ar(0), DC.ar(0), input]);
                        ReplaceOut.ar(0, Limiter.ar(input)) ;
                    }).add;
                    Server.default.sync;
                    lmFunc.value;
                    CmdPeriod.add(lmFunc);
                    "StageLimiter active".postln;
                }
            }

            *deactivate
            {
                activeSynth.free;
                CmdPeriod.remove(lmFunc);
                "StageLimiter inactive...".postln;
            }
        }
    '''

    renardo_start_code = f'''
        Renardo.start();
        Renardo.midi();
    '''

    with open(SC_USER_EXTENSIONS_DIR / 'StageLimiter.sc', mode="w") as file:
        file.write(stagelimiter_sc_class)

    with open(SC_USER_EXTENSIONS_DIR / 'Renardo.sc', mode="w") as file:
        file.write(renardo_sc_class)

    with open(SC_USER_CONFIG_DIR / 'start_renardo.scd', mode="w") as file:
        file.write(renardo_start_code)
